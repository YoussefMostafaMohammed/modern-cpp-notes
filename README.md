# modern-cpp-notes

This repository contains personal study notes and practical examples for **Modern C++** (C++11â€“C++23).  
It covers Object-Oriented Programming, Smart Pointers, Templates, Value Categories (lvalues, rvalues, universal references), Compile-Time Programming with `enum class` and `constexpr`, and Critical Modern Features like `inline`, `using`, and `noexcept`.

Think of this as a mini-book for modern C++ concepts, with a clickable Table of Contents for easy navigation.

---

## ðŸ“š Complete Table of Contents

### **1. Object-Oriented Programming (OOP)**
- [0.1 What is OOP? - The Four Pillars](1%20-%20OOP/OOP.md#01-what-is-oop--the-four-pillars)
- [0.2 Classes vs Objects - Blueprint vs Instance](1%20-%20OOP/OOP.md#02-classes-vs-objects--the-blueprint-vs-the-instance)
- [0.3 What is Inheritance? - "Is-A" Relationship](1%20-%20OOP/OOP.md#03-what-is-inheritance--the-is-a-relationship)
- [0.4 How Class Size is Measured](1%20-%20OOP/OOP.md#04-how-class-size-is-measured)
- [1.1 Access Control (`public`, `protected`, `private`)](1%20-%20OOP/OOP.md#11-public-protected-private--the-encapsulation-trinity)
- [1.2 `struct` vs `class`](1%20-%20OOP/OOP.md#12-struct-vs-class--the-default-difference)
- [1.3 `friend` - Encapsulation Breaker](1%20-%20OOP/OOP.md#13-friend--the-encapsulation-breaker)
- [1.4 `= default` - Compiler-Generated Functions](1%20-%20OOP/OOP.md#14-default--explicit-compiler-generated-functions)
- [1.5 `static` Keyword](1%20-%20OOP/OOP.md#15-the-static-keyword---class-level-vs-instance-level)
- [2.1 Inheritance Types (`public`, `protected`, `private`)](1%20-%20OOP/OOP.md#21-inheritance-types-public-protected-private)
- [2.2 Basic Virtual Functions](1%20-%20OOP/OOP.md#22-basic-virtual-functions--the-polymorphism-gateway)
- [2.3 Pure Virtual Functions & Abstract Classes](1%20-%20OOP/OOP.md#23-pure-virtual-functions--abstract-classes)
- [2.4 Virtual Destructors](1%20-%20OOP/OOP.md#24-virtual-destructors--the-memory-leak-preventer)
- [3.1 Diamond Problem Without `virtual`](1%20-%20OOP/OOP.md#31-the-diamond-problem-without-virtual)
- [3.2 Virtual Inheritance - Solution](1%20-%20OOP/OOP.md#32-virtual-inheritance--the-solution)
- [3.3 Memory Layout Cost Analysis](1%20-%20OOP/OOP.md#33-memory-layout-cost-analysis)
- [4.1 What Are Vtables & Vptrs](1%20-%20OOP/OOP.md#41-what-are-vtables-and-vptrs)
- [4.2 Single Inheritance Vtable Layout](1%20-%20OOP/OOP.md#42-single-inheritance-vtable-layout)
- [4.3 Multiple & Virtual Inheritance Vtables](1%20-%20OOP/OOP.md#43-multiple--virtual-inheritance---primary--secondary-vtables)
- [4.4 Thunks - `this` Adjustment](1%20-%20OOP/OOP.md#44-thunks--the-this-pointer-adjustment)
- [5.1 The VTT (Virtual Table Table)](1%20-%20OOP/OOP.md#51-the-vtt-virtual-table-table)
- [5.2 Construction Vtables](1%20-%20OOP/OOP.md#52-construction-vtables--safety-during-build)
- [5.3 Destruction Sequence & VTT Entries](1%20-%20OOP/OOP.md#53-destruction-sequence--vtt-entries)
- [6.1 RTTI: `type_info` & `dynamic_cast`](1%20-%20OOP/OOP.md#61-type_info-and-dynamic_cast)
- [6.2 `top_offset` - Most Derived Object](1%20-%20OOP/OOP.md#62-top_offset--finding-the-most-derived-object)
- [6.3 `vbase_offset` - Locating Virtual Bases](1%20-%20OOP/OOP.md#63-vbase_offset--locating-virtual-bases)
- [7.1 When to Use Virtual Inheritance](1%20-%20OOP/OOP.md#71-when-to-use-virtual-inheritance)
- [7.2 Performance Considerations](1%20-%20OOP/OOP.md#72-performance-considerations)
- [7.3 Common Pitfalls](1%20-%20OOP/OOP.md#73-common-pitfalls)
- [Appendix A.1 Dumping Vtables](1%20-%20OOP/OOP.md#a1-dumping-vtables-with-gccclang)
- [Appendix A.2 Decoding Mangled Names](1%20-%20OOP/OOP.md#a2-decoding-mangled-names)

### **2. Smart Pointers**
- [`std::unique_ptr` â€” Unique Ownership](2%20-%20SmartPointers/SmartPointers.md#stdunique_ptr--unique-ownership)
- [`std::move()` vs `.reset()`](2%20-%20SmartPointers/SmartPointers.md#stdmove-vs-reset)
- [`std::shared_ptr` â€” Shared Ownership](2%20-%20SmartPointers/SmartPointers.md#stdshared_ptr--shared-ownership)
- [`std::weak_ptr` â€” Weak Ownership](2%20-%20SmartPointers/SmartPointers.md#stdweak_ptr--weak-ownership)
- [Comparison Table](2%20-%20SmartPointers/SmartPointers.md#comparison-table)
- [Smart Pointer Internals](2%20-%20SmartPointers/SmartPointers.md#smart-pointer-internals)
- [Interview Questions & Deep Dive](2%20-%20SmartPointers/SmartPointers.md#interview-questions--deep-dive)
- [Practical Guidelines](2%20-%20SmartPointers/SmartPointers.md#practical-guidelines)

### **3. Templates**
- [Template Argument Deduction](3%20-%20Templates/Templates.md#3-template-argument-deduction)
- [Substitution in Templates](3%20-%20Templates/Templates.md#4-substitution-in-templates)
- [Reference Collapsing Rules](3%20-%20Templates/Templates.md#5-reference-collapsing-rules)
- [Forwarding (Universal) References](3%20-%20Templates/Templates.md#6-forwarding-universal-references)
- [Perfect Forwarding](3%20-%20Templates/Templates.md#12-perfect-forwarding)
- [Common Pitfalls & Special Cases](3%20-%20Templates/Templates.md#13-common-pitfalls)
- [Quick Summary Table](3%20-%20Templates/Templates.md#19-quick-summary-table)

### **4. Lvalues, Rvalues & Universal References**
- [lvalues and rvalues](4%20-%20Lvalue-Rvalue-UniversalReference/Lvalue-Rvalue-UniversalReference.md#1-lvalues-and-rvalues)
- [Differences between `T&` and `T&&`](4%20-%20Lvalue-Rvalue-UniversalReference/Lvalue-Rvalue-UniversalReference.md#2-differences-between-t-and-t)
- [Step-by-Step Deduction Flow](4%20-%20Lvalue-Rvalue-UniversalReference/Lvalue-Rvalue-UniversalReference.md#7-step-by-step-flow-argument--deduction--substitution--collapse--final-type)
- [Why `T` is deduced as `int&` for lvalues](4%20-%20Lvalue-Rvalue-UniversalReference/Lvalue-Rvalue-UniversalReference.md#8-why-t-is-deduced-as-int-for-lvalues-not-just-int)
- [Printing `T` and `arg` Types](4%20-%20Lvalue-Rvalue-UniversalReference/Lvalue-Rvalue-UniversalReference.md#11-printing-t-and-arg-type)
- [Advanced Topics & Best Practices](4%20-%20Lvalue-Rvalue-UniversalReference/Lvalue-Rvalue-UniversalReference.md#16-advanced-topics)
- [Visual ASCII Diagram: The Full Flow](4%20-%20Lvalue-Rvalue-UniversalReference/Lvalue-Rvalue-UniversalReference.md#20-visual-ascii-diagram-the-full-flow)

### **5. Enum Classes & Compile-Time Programming**
- [5.1 Enum Classes vs Traditional Enums](5%20-%20EnumClass-Constexpr/EnumClass-Constexpr.md#51-enum-classes-vs-traditional-enums)
- [5.2 The Three Critical Problems with Traditional Enums](5%20-%20EnumClass-Constexpr/EnumClass-Constexpr.md#52-the-three-critical-problems-with-traditional-enums)
- [5.3 Enum Class Features and Benefits](5%20-%20EnumClass-Constexpr/EnumClass-Constexpr.md#53-enum-class-features-and-benefits)
- [5.4 What `constexpr` Actually Does](5%20-%20EnumClass-Constexpr/EnumClass-Constexpr.md#54-what-constexpr-actually-does)
- [5.5 The Evolution of `constexpr` Across C++ Standards](5%20-%20EnumClass-Constexpr/EnumClass-Constexpr.md#55-the-evolution-of-constexpr-across-c-standards)
- [5.6 `constexpr` vs `const` vs `#define`: The Complete Triad](5%20-%20EnumClass-Constexpr/EnumClass-Constexpr.md#56-constexpr-vs-const-vs-define)
- [5.7 Performance Impact and Assembly-Level Analysis](5%20-%20EnumClass-Constexpr/EnumClass-Constexpr.md#57-performance-impact-and-assembly-level-analysis)
- [5.8 Side Effects and Purity in Compile-Time Contexts](5%20-%20EnumClass-Constexpr/EnumClass-Constexpr.md#58-side-effects-and-purity)
- [5.9 Template Metaprogramming - The Pre-`constexpr` Era](5%20-%20EnumClass-Constexpr/EnumClass-Constexpr.md#59-template-metaprogramming)
- [5.10 Declaration vs Definition - The Linker's Perspective](5%20-%20EnumClass-Constexpr/EnumClass-Constexpr.md#510-declaration-vs-definition)
- [5.11 C++17: The `inline` Revolution](5%20-%20EnumClass-Constexpr/EnumClass-Constexpr.md#511-c17-the-inline-revolution)

### **6. Functors, Lambdas & Compile-Time Customizability**
- [6.1 Designing for Reusability in Modern C++](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#61-designing-for-reusability-in-modern-c)
- [6.2 Customizability through Callbacks](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#62-customizability-through-callbacks)
- [6.3 What Is a Callback?](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#63-what-is-a-callback)
- [6.4 Types of Callbacks in C++](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#64-types-of-callbacks-in-c)
- [6.5 Why Were Functors Invented? (Historical Context)](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#65-why-were-functors-invented-historical-context)
- [6.6 Problem 1 â€“ "Piping State" into Predicates](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#66-problem-1--piping-state-into-predicates)
- [6.7 Problem 2 â€“ Function Pointers "Kill Inlining"](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#67-problem-2--function-pointers-kill-inlining)
- [6.8 Problem 3 â€“ Overload Sets & Template Operators](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#68-problem-3--overload-sets--template-operators)
- [6.9 Functors: The Foundation](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#69-functors-the-foundation)
- [6.10 Lambdas: Compiler-Generated Functors](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#610-lambdas-compiler-generated-functors)
- [6.11 std::function: Type-Erased Wrapper](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#611-stdfunction-type-erased-wrapper)
- [6.12 Performance Deep Dive â€“ Assembly & Benchmarks](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#612-performance-deep-dive--assembly--benchmarks)
- [6.13 Summary Table â€“ Callback Types](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#613-summary-table--callback-types)
- [6.14 Customizability through Template Parameters](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#614-customizability-through-template-parameters)
- [6.15 Templates with Callable Parameters](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#615-templates-with-callable-parameters)
- [6.16 Templates with Types (Policy Classes)](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#616-templates-with-types-policy-classes)
- [6.17 Why Template Customizability Matters](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#617-why-template-customizability-matters)
- [6.18 Concepts (C++20)](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#618-concepts-c20)
- [6.19 Comparison: When to Use What](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#619-comparison-when-to-use-what)
- [6.20 Modern C++ Best Practices](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#620-modern-c-best-practices)
- [6.21 Real-World Idiomatic Patterns](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#621-real-world-idiomatic-patterns)
- [6.22 Decision Tree â€“ Which One Should I Pick?](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#622-decision-tree--which-one-should-i-pick)
- [6.23 Complete Example â€“ Flexible Logger System](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#623-complete-example--flexible-logger-system)
- [6.24 Key Takeaways](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#624-key-takeaways)
- [6.25 Further Reading & Sources](6%20-%20FunctorsAndLambda/FunctorsAndLambda.md#625-further-reading--sources)

### **7. Inline, Using, and Noexcept - Critical Modern Features **
- [ 7.1 The Three Features That Solve Decades-Old Problems ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#71-the-three-features-that-solve-decades-old-problems)
- [ 7.2 ` inline ` Variables - Solving the ODR Nightmare ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#72-inline-variables-solving-the-odr-nightmare)
- [ 7.3 The Problem: Static Initialization Hell ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#73-the-problem-static-initialization-hell)
- [ 7.4 Before C++17: Two Bad Options ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#74-before-c17-two-bad-options)
- [ 7.5 After C++17: The ` inline ` Solution ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#75-after-c17-the-inline-solution)
- [ 7.6 ` using ` Type Aliases - Replacing ` typedef ` ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#76-using-type-aliases-replacing-typedef)
- [ 7.7 The Readability Problem with ` typedef ` ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#77-the-readability-problem-with-typedef)
- [ 7.8 Template Aliases: The Game Changer ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#78-template-aliases-the-game-changer)
- [ 7.9 Template Parameter Evaluation: The Correct Mental Model ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#79-template-parameter-evaluation-the-correct-mental-model)
- [ 7.10 Common Confusion: Why Not ` std::vector<T><int> `? ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#710-common-confusion-why-not-stdvectortint)
- [ 7.11 ` noexcept ` - The Savior of Move Semantics ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#711-noexcept-the-savior-of-move-semantics)
- [ 7.12 What ` noexcept ` Does ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#712-what-noexcept-does)
- [ 7.13 The ` throw() ` Disaster (Pre-C++11) ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#713-the-throw-disaster-pre-c11)
- [ 7.14 Three Critical Reasons for ` noexcept ` ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#714-three-critical-reasons-for-noexcept)
- [ 7.15 Reason 1: Enable Move Semantics ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#715-reason-1-enable-move-semantics)
- [ 7.16 Move Semantics and Exception Safety - Deep Dive ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#716-move-semantics-and-exception-safety-deep-dive)
- [ 7.17 Why ` std::vector ` Refuses Throwing Moves ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#717-why-stdvector-refuses-throwing-moves)
- [ 7.18 The Strong Exception Guarantee ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#718-the-strong-exception-guarantee)
- [ 7.19 Scenario: Throwing Move (Corrupted State) ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#719-scenario-throwing-move-corrupted-state)
- [ 7.20 Scenario: Copy (Safe State) ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#720-scenario-copy-safe-state)
- [ 7.21 Complete Code Example - Resource Class ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#721-complete-code-example-resource-class)
- [ 7.22 Expected Output - Proving Vector Uses Copies ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#722-expected-output---proving-vector-uses-copies)
- [ 7.23 The Fix: Adding ` noexcept ` ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#723-the-fix-adding-noexcept)
- [ 7.24 Performance Impact: 100x Speedup ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#724-performance-impact-100x-speedup)
- [ 7.25 The Moved-From State - Why ` nullptr ` is Mandatory ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#725-the-moved-from-state-why-nullptr-is-mandatory)
- [ 7.26 The Move Constructor Implementation Explained ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#726-the-move-constructor-implementation-explained)
- [ 7.27 Double-Free Prevention Rule ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#727-double-free-prevention-rule)
- [ 7.28 Exception Safety in Move Constructors ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#728-exception-safety-in-move-constructors)
- [ 7.29 The State Timeline During Move ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#729-the-state-timeline-during-move)
- [ 7.30 ` std::move_if_noexcept ` - Conditional Move vs Copy ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#730-stdmove_if_noexcept---conditional-move-vs-copy)
- [ 7.31 What ` std::move_if_noexcept ` Does ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#731-what-stdmove_if_noexcept-does)
- [ 7.32 Implementation Details ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#732-implementation-details)
- [ 7.33 How It Works - Step by Step ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#733-how-it-works---step-by-step)
- [ 7.34 Where the Standard Library Uses It ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#734-where-the-standard-library-uses-it)
- [ 7.35 ` std::swap ` Implementation ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#735-stdswap-implementation)
- [ 7.36 ` std::vector::resize ` Internal Logic ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#736-stdvectorresize-internal-logic)
- [ 7.37 Performance Comparison: Heavy vs LightButThrowy ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#737-performance-comparison-heavy-vs-lightbutthrowy)
- [ 7.38 Best Practices and Guidelines ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#738-best-practices-and-guidelines)
- [ 7.39 Complete Examples Collection ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#739-complete-examples-collection)
- [ 7.40 Summary Tables - Quick Reference ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#740-summary-tables---quick-reference)
- [ 7.41 Q&A Summary - All Key Questions Answered ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#741-qa-summary---all-key-questions-answered)
- [ 7.42 Further Reading & Sources ](7%20-%20InlineUsingNoexcept/InlineUsingNoexcept.md#742-further-reading--sources)

---

## License

This repository is for personal study and reference.
